How to run this code: There are four separate main modules. They are located at "Trees/TreeDisplay.elm", "Arithmetic/MathDisplay.elm", "Lambda/LambdaDisplay.elm", and "CFG/GrammarDisplay.elm". They can be compiled individuall with "elm make", or run with "elm reactor".


My project, originally planned to be a red-black tree visualization, became a little more than that. The foundation of the project is a library for binary tree visualization (DrawableTree.elm, contained in the "Drawable" directory). As it turns out, true minimal width tree drawing is NP-complete (https://www.emis.de/journals/JGAA/accepted/2004/MarriottStuckey2004.8.3.pdf). However, there do exist some good approximation algorithms. I implemented the Reingold-Tilford algorithm, and the resulting trees look rather nice in practice. They're very practical in that it's possible to view extremely unbalanced trees in a small display. The library exposes a "PreDrawableTree" data structure, which any tree library need only write a function to from their own tree type. The programmer is able to provide some style information as well, including node shape, size, and color.

Because a tree visualization library isn't much to look at on its own (it's just a library, we have to actually give it some trees to visualize if we want to see anything), I also wrote four applications making use of the library which each does some interesting things. The first was a comparison of a red-black tree and a non-self-balancing binary search tree. A user is able to insert numbers into the trees and see the differences that arise between the two. In addition, a Random button was added to allow the user to rapidly insert many nodes into the tree. This was a good first application for the DrawableTree library. It was conceptually very closely linked, and it drew directly from topics learned in class.

After the first application, I began taking less direct approaches to the ideas of what could be a binary tree. The next application was an arithmetic parse tree visualizer and evaluator. Many basic arithmetic functions are binary functions, which made them the perfect target language for an binary abstract syntax tree. For this, I wrote a parser for arithmetic expressions. I also wrote a single-step evaluator for the resulting expression trees. In this application, users are able to write arithmetic expressions, and parse them into trees, and then able to see individual evaluation steps. It's a good visualization tool for explaining to a beginner why a program is a tree.

Arithmetic expressions are kind of basic, so I thought I could take that same idea and apply it to a more interesting language. This gave rise to a parser, syntax tree visualizer, and single step evaluator for the untyped lambda calculus (an LC compiler was another of my project proposals). This one was very interesting to write, and included of course the parser for lambda calculus, and the evaluator which takes a full beta reduction evalutation strategy. In addition, the compiler includes capture avoidance substitution and a small amount of syntactic sugar. I felt I couldn't, in good conscience, get through a functional programming class without writing a lambda calculus compiler, so this was a good exercise in purely functional things.

All the parsing was reminding me of my Intro to Formal Languages class, and that made me think of another type of binary tree: a parse tree for a context free grammar in Chomsky normal form. This led me to my final application, a parser for descriptions of context free grammars, and an implementation of the CYK parsing algorithm with the extension of the ability to draw parse trees for strings that are members of the specified language. Parsing becomes a bit of an overloaded term here, so be mindful of the distinctions. This application allows users to define their own context free grammar in Chomsky normal form and generate parse trees for strings in the language. In addition, it also allows them to generate random strings that are members of their language. This has a natural and unavoidable proclivity for failure, however, as it's possible that a randomly generated parse tree for a certain language could "diverge", in that it could grow forever due to the structure of the grammar. Despite this, it's generally easy to tell when this type might happen by simple manual inspection of the grammar. I was also able to create grammars which generate a subset of the acceptable strings for my arithmetic and lambda parsing applications, which allows the applications to mesh together in a fun way. This CYK parser was very satisfying to write and get working, as it felt more heavily "theoretical" than most things I had done before.

In summary, the four applications I made were satisfying to build and let me apply functional programming principles. If I had more time, I would implement a more theoretically sound strategy for random string generation from CFGs, and perhaps implement an additional application.